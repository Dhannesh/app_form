# Working with Input Widgets and Forms

Mobile applications often need to collect user input. This can be for configuration settings, for getting personal information or just for app interactions. User input in Flutter is collected using input widgets and these input widgets can be embedded within forms.

In this app, you will learn the different types of input widgets that you can use to accept different types of inputs, continuous inputs and categorical inputs. You will understand the use cases and special characteristics of these different input types and how these inputs can be grouped together into forms with a submit button. You will implement and handle changes in a variety of different input types.

You will see how to use text fields for free-form inputs, radio buttons for single selections, checkboxes for multiple selections, and the Switch widget for binary input. You will use change handlers to handle input changes and state updates, and use grouped widgets to update the same state using multiple inputs.

Finally, you will see how input widgets can be embedded to be part of Flutter forms. You will learn how FormState is accessed and validated using FormField widgets and how you can create custom widgets that can be embedded in Flutter forms. When you're finished with this course, you will be able to create input widgets to accept all kinds of user inputs and embed these widgets in forms and use validators and onSaved callbacks with your forms.

## Input widget in Flutter
The framework itself contains a number of built-in widgets for the most common kinds of inputs. Now, each of these widgets available in the framework can be styled and decorated to get the right look and feel for whatever your use case is. Each input widget has its own set of decoration properties. Also, each widget can respond to changes and update its state based on what the user has specified. Input widgets can be categorized into 2 broad types. Certain input widgets, such as text fields, can accept free-form input, so, you can type an alphanumeric characters, long sentences, multi-line sentences, and so on. There are other input widgets that constrain what inputs you can specify to a specific set or range of values. Drop-downs, radio buttons, checkboxes, sliders, all of these are examples of input widgets that constrain your input.

Essentially, when you think of what kind of input widget you want to use, think about what kind of response you expect from the user. Some input widgets, such as text fields, will allow free-form responses. That's when you don't know what the user might input, comments or reviews. If you want to ensure that the user responses are from a constrained set of values, then you should use a constrained input widget, such as those that accept categorical values. Radio buttons and drop-downs allow you to select one from many categories. Or you might have input widgets that accept a range of values, sliders for example.

Let's do a quick overview of some of these input widgets and see why you might use them. The TextField is what you'll use to accept free-form text input. Now, in Flutter, your text fields can be single line text fields or accept multi-line input. Flutter also gives you the option to constrain what you can accept in your TextField. You can say you want only numeric input, or you can tailor the keyboard to accept email addresses, you can add validators and so on. You can also decorate your text fields using an outline, hint text, labels, icons, etc. Now, if you want the user to choose one amongst a discrete set of values, you may use the radio button. This is a single-select input widget. It's used to accept a discrete value from a set of probable values.

You can also group multiple radio buttons together to form a set of possible inputs. And the radio button is the most useful when you have a few choices and you want the user to choose one amongst them. If you have a discrete set of options and you want the user to choose one or more of these options, you can use the checkbox which is a multi-select input and this is what you'll use to accept multiple values or multiple options from the user. If you want the user to make a binary choice, yes, no, true, false, up, down, choose the switch input widget that allows binary input.

This is what you'll use to have the user make a choice between two discrete values. True/false, yes/no, on/off, enabled/disabled. These are all examples where you might choose the switch input. The drop-down is another example of a single-select input. This is what you'll use when you want the user to accept a discrete value from a set. Now, a drop-down is a better choice as compared with the radio button if you have a large number of choices that the user can select from. Input widgets in Flutter can be used standalone to accept a single response, or you can group multiple widgets together to form a form. A form is just a set of input fields used to collect responses from the user. These responses are then validated and submitted to the server for processing.

The form submission happens when you click the submit button that is often associated with the form. When you use forms in Flutter, it's common practice for the input widgets to be FormField elements. A FormField widget in Flutter is usually part of a form that may contain other widgets that are also FormFields. FormField widgets have a certain standard set of properties that are useful when working with forms. For example, every FormField widget has an initial value that you can assign to set up the initial state of the widget.

Every FormField widget accepts a validation callback. This callback is invoked when you validate all of the widgets in a form. Every FormField widget has a validation mode that you can use to specify when exactly that particular field should be validated. Should validate it right away on submit you can specify this. And finally, every FormField has an onSaved callback. This is the callback that is invoked when you invoke save on the FormState. So, now is a good time to explain what exactly the FormState is. Every form widget that you create in Flutter is associated with the state object and that is the FormState. The FormField widgets that are included in a form become part of the form's state.

Every form that you'll use in Flutter has a FormState object for the form as a whole and it holds state information for all of the widgets and you can call methods on this FormState, for example, calling FormState.save() will invoke each form field's onSaved callback. You can call FormState.validate to validate all of the FormFields that exist in a form. The FormState allows you to operate on the form as a whole. When you're working with forms, you'll need to use a global key to uniquely identify your form. A global key is a key that is unique across the entire application, and this key can be used to uniquely identify your app's elements. Global keys associated with elements are commonly used to provide access to other objects associated with those elements, such as the state of the object or the BuildContext of the object. Global keys, when used with forms, allow you to specify and manipulate the FormState for a form as a whole.
