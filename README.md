# Working with Input Widgets and Forms

Mobile applications often need to collect user input. This can be for configuration settings, for getting personal information or just for app interactions. User input in Flutter is collected using input widgets and these input widgets can be embedded within forms.

In this app, you will learn the different types of input widgets that you can use to accept different types of inputs, continuous inputs and categorical inputs. You will understand the use cases and special characteristics of these different input types and how these inputs can be grouped together into forms with a submit button. You will implement and handle changes in a variety of different input types.

You will see how to use text fields for free-form inputs, radio buttons for single selections, checkboxes for multiple selections, and the Switch widget for binary input. You will use change handlers to handle input changes and state updates, and use grouped widgets to update the same state using multiple inputs.

Finally, you will see how input widgets can be embedded to be part of Flutter forms. You will learn how FormState is accessed and validated using FormField widgets and how you can create custom widgets that can be embedded in Flutter forms. When you're finished with this course, you will be able to create input widgets to accept all kinds of user inputs and embed these widgets in forms and use validators and onSaved callbacks with your forms.

## Input widget in Flutter
The framework itself contains a number of built-in widgets for the most common kinds of inputs. Now, each of these widgets available in the framework can be styled and decorated to get the right look and feel for whatever your use case is. Each input widget has its own set of decoration properties. Also, each widget can respond to changes and update its state based on what the user has specified. Input widgets can be categorized into 2 broad types. Certain input widgets, such as text fields, can accept free-form input, so, you can type an alphanumeric characters, long sentences, multi-line sentences, and so on. There are other input widgets that constrain what inputs you can specify to a specific set or range of values. Drop-downs, radio buttons, checkboxes, sliders, all of these are examples of input widgets that constrain your input.

Essentially, when you think of what kind of input widget you want to use, think about what kind of response you expect from the user. Some input widgets, such as text fields, will allow free-form responses. That's when you don't know what the user might input, comments or reviews. If you want to ensure that the user responses are from a constrained set of values, then you should use a constrained input widget, such as those that accept categorical values. Radio buttons and drop-downs allow you to select one from many categories. Or you might have input widgets that accept a range of values, sliders for example.

Let's do a quick overview of some of these input widgets and see why you might use them. The TextField is what you'll use to accept free-form text input. Now, in Flutter, your text fields can be single line text fields or accept multi-line input. Flutter also gives you the option to constrain what you can accept in your TextField. You can say you want only numeric input, or you can tailor the keyboard to accept email addresses, you can add validators and so on. You can also decorate your text fields using an outline, hint text, labels, icons, etc. Now, if you want the user to choose one amongst a discrete set of values, you may use the radio button. This is a single-select input widget. It's used to accept a discrete value from a set of probable values.

You can also group multiple radio buttons together to form a set of possible inputs. And the radio button is the most useful when you have a few choices and you want the user to choose one amongst them. If you have a discrete set of options and you want the user to choose one or more of these options, you can use the checkbox which is a multi-select input and this is what you'll use to accept multiple values or multiple options from the user. If you want the user to make a binary choice, yes, no, true, false, up, down, choose the switch input widget that allows binary input.

This is what you'll use to have the user make a choice between two discrete values. True/false, yes/no, on/off, enabled/disabled. These are all examples where you might choose the switch input. The drop-down is another example of a single-select input. This is what you'll use when you want the user to accept a discrete value from a set. Now, a drop-down is a better choice as compared with the radio button if you have a large number of choices that the user can select from. Input widgets in Flutter can be used standalone to accept a single response, or you can group multiple widgets together to form a form. A form is just a set of input fields used to collect responses from the user. These responses are then validated and submitted to the server for processing.

The form submission happens when you click the submit button that is often associated with the form. When you use forms in Flutter, it's common practice for the input widgets to be FormField elements. A FormField widget in Flutter is usually part of a form that may contain other widgets that are also FormFields. FormField widgets have a certain standard set of properties that are useful when working with forms. For example, every FormField widget has an initial value that you can assign to set up the initial state of the widget.

Every FormField widget accepts a validation callback. This callback is invoked when you validate all of the widgets in a form. Every FormField widget has a validation mode that you can use to specify when exactly that particular field should be validated. Should validate it right away on submit you can specify this. And finally, every FormField has an onSaved callback. This is the callback that is invoked when you invoke save on the FormState. So, now is a good time to explain what exactly the FormState is. Every form widget that you create in Flutter is associated with the state object and that is the FormState. The FormField widgets that are included in a form become part of the form's state.

Every form that you'll use in Flutter has a FormState object for the form as a whole and it holds state information for all of the widgets and you can call methods on this FormState, for example, calling FormState.save() will invoke each form field's onSaved callback. You can call FormState.validate to validate all of the FormFields that exist in a form. The FormState allows you to operate on the form as a whole. When you're working with forms, you'll need to use a global key to uniquely identify your form. A global key is a key that is unique across the entire application, and this key can be used to uniquely identify your app's elements. Global keys associated with elements are commonly used to provide access to other objects associated with those elements, such as the state of the object or the BuildContext of the object. Global keys, when used with forms, allow you to specify and manipulate the FormState for a form as a whole.

## TextField Widget
I return a MaterialApp. This widget is the starting point of your application and it tells Flutter that you're planning to use material components and material design in your app. I have set a theme for this MaterialApp with the primarySwatch set to deepPurple, and that's why our app bar appears in deepPurple if you look at the emulator. The home property is set to a Scaffold. The Scaffold widget is used under the MaterialApp and it gives you many basic functionalities that you'll need in an app that uses material design like AppBar, drawer, floating action button, and so on.

Our Scaffold has an AppBar property which is set to the Text Insta Store and then the body of the Scaffold is set to this TextInputWidget. This TextInputWidget is a custom SatefulWidget that I have defined that holds the text field that you see displayed in the emulator. Look at this TextInputWidget class extends the StatefulWidget base class. Now, at this point in time, this widget does not hold state, but you can imagine that whatever the user types into the text, you might want to save in a member variable, and this is exactly why I've chosen to make this a StatefulWidget, though it actually does not store any state at this point in time.

The TextField class is a material design TextField. This lets the user enter text into the application, either with the hardware keyboard or with an on-screen keyboard. Now, by default, a TextField has a decoration that draws a divider below the TextField, and you can see that in the emulator, the gray line is the divider indicating where the TextField is. The TextField is just above that divider.

Now, I have wrapped this TextField in a center widget and a padding widget so that it's centered nicely in the middle of our app. Now, you can use this TextField to enter text. The minute you select the TextField, you'll see that your software keyboard pops up. Now, I'll use my hardware keyboard to enter text into the TextField. It's useful to have a label associated with a TextField and you can set that label using the decoration property of the TextField. When my app hot reloads, you can see the change in the emulator, you can see that my TextField now has a label, Share your thoughts. Now, this particular InputDecoration object has just one property assigned. But you should know that the InputDecoration class contains borders, labels, icons and styles. Everything that you need to decorate a material design text field. You have to admit that our TextField is now looking a lot better. 

The prefixIcon property will set an Icon at the beginning of your TextField. The InputDecoration class allows you to set suffix icons, styles for your icons, colors for your icons, and many other decoration properties. I want to change the border of this TextField, so that the entire TextField has an outline. Now, whether you want the border or not, that's up to you and that's part of your app's design. But I really think the OutlineInputBorder gives a very clear representation of where exactly the TextField is. You can also set the border to InputBorder.none or the underline input border. That is the default. You'll see that when the TextField is selected and I'm about to select it right now, it gets this nice purple outline. And the message icon is also displayed in the purple color, that is our primary swatch remember. Another common practice when specifying text fields in your mobile applications is to specify a hintText that appears within the TextField and is replaced by whatever you type in. You can type in letters and you can type in numbers, special characters, anything. But let's say you know that your TextField only accepts numeric inputs. Maybe it's the field for ZIP code or age or some numeric value. You can specify your keyboardType, keyboardType set to TextInputType.number as I've done here, will pop up the numeric keyboard when your TextField is selected.

And this is a really nice usability feature. Your users know that this field expects numeric input, they should use the numeric keyboard. You can change the keyboard input type to be text. That is the default value. This is what brings up the alphanumeric keyboard. When you do not specify any keyboardType for your TextField, it is this TextInputType.text that is the default value bringing up the alphanumeric keyboard. Let's say that this TextField is for the user to type in an email address. You may want a keyboard that enables the @ sign for the emailAddress.

Set your TextInputType to emailAddress. Now, when you bring up the keyboard, notice that the keyboard has an @ sign at the bottom left. This is facilitated by the TextInputType.emailAddress that we have specified on line 48. What if you want to restrict the length of the input that your TextField accepts? Well, you can set the maxLength property. Here I've set maxLength to 5 and when your app reloads, take a look at the emulator and observe that just below the TextField, you see 0/5. You've typed in 0 characters out of the 5 permitted in this TextField. Now, let me try and type something in this TextField. I'm going to try and type in Awesome but after the first 5 characters, Aweso, it doesn't let me type in any further. I've reached my limit. Let me increase the maxLength of my TextField. Instead of 5, I'm going to set 50, and this will update the limit in the emulator as well. I've typed in 0 out of 50 so far.

## Handling Updates to the Text Field 

